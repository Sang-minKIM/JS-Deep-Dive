# 25. 클래스

## 📌 25.1 클래스는 프로토타입의 문법적 설탕인가?

클래스는 ES6에서 도입된 새로운 **객체 생성 메커니즘** 이다.  
프로토타입에 기반하여 객체를 생성하므로 기존 [프로토타입 기반 패턴](https://github.com/likelion-ssu/JS-Deep-Dive/blob/main/JS%20Deep%20Dive%20cheat-sheet/19_프로토타입.md#-196-객체-생성-방식과-프로토타입의-결정)의 문법적 설탕이라고 볼 수있지만, 더욱 엄격하고 추가적인 기능을 제공한다.

### 클래스의 특징 (생성자 함수와의 차이점)

1. `new` 연산자 없이 호출하면 에러가 발생한다.
2. `extends`와 `super` 키워드로 상속을 지원한다.
3. 호이스팅이 발생하지 않는 것처럼 동작한다.
4. 클래스 내의 코드에는 암묵적으로 `strict mode`가 지정된다.
5. 클래스의 constructor, 프로토타입 메소드, 정적메서드는 모든 프로퍼티 어트리뷰트 \[\[Enumerable]]의 값이 `false`로 열거할 수 없다.

<br/>

## 📌 25.2 클래스 정의

- 클래스는 `class` 키워드를 사용하여 정의한다.
  ```js
  class Person {}
  ```
- 클래스의 이름은 **파스칼케이스** 를 사용하는 것이 일반적이다.
- 클래스는 함수이자 **일급객체** 로 표현식으로 정의할 수 있으며, [일급객체의 특성](https://github.com/likelion-ssu/JS-Deep-Dive/blob/main/JS%20Deep%20Dive%20cheat-sheet/18_함수와-일급-객체.md#-181-일급-객체)을 갖는다.
  ```js
  const Person = class {}; // 익명 클래스 표현식
  const Person = class MyClass {}; // 기명 클래스 표현식
  ```
- 클래스의 몸체에는 0개 이상의 메서드(constructor, 프로토타입 메서드, 정적 메서드)를 정의할 수 있다.
  ```js
  class Person {
    // 생성자
    constructor(name) {
      this.name = name;
    }
    // 프로토타입 메서드
    sayHi() {
      console.log(`Hi! My name is ${this.name}`);
    }
    // 정적 메서드
    static sayHello() {
      console.log('Hello!');
    }
  }
  ```

<br/>

## 📌 25.3 클래스 호이스팅

- 클래스 선언문으로 정의한 클래스는 호이스팅되어 **런타임 이전** 에 함수 객체와 프로토타입을 생성한다.
- 클래스는 평가되어 인스턴스를 생성하는 **생성자 함수 객체** 가 되며, 클래스의 프로토타입 객체의 `constructor` 는 클래스 자신을 가리킨다.
- 클래스 선언문은 마치 **호이스팅이 발생하지 않는 것처럼** 동작한다. (`let`, `const`로 선언한 변수와 같이 `TDZ` 존재)

<br/>

## 📌 25.4 인스턴스 생성

- 클래스는 생성자 함수로 평가되고, 반드시 `new` 연산자와 함께 호출되어야한다.
- **기명 클래스 표현식** 의 클래스 이름은 외부 코드에서 접근이 불가하므로, 클래스를 가리키는 식별자를 사용해 생성해야한다.
  ```js
  const Person = class MyClass {};
  const me = new Person(); // Person {}
  const me = Person(); // TypeError: Class constructor Person cannot be invoked without 'new'
  const you = new MyClass(); // ReferenceError: MyClass is not defined
  ```

<br/>

## 📌 25.5 메서드

클래스의 몸체에는 0개 이상의 메서드만 선언할 수 있으며, `constructor`, `프로토타입 메서드`, `정적 메서드`의 세 가지가 있다.

### Constructor

`constructor`는 **인스턴스를 생성하고 초기화하기 위한 특수한 메서드** 로, 이름을 변경할 수 없다.  
`constructor`는 메서드로 해석되지 않고, 클래스가 평가되어 생성한 함수의 일부가 되어 객체 생성시 동작을 정의한다.

#### constructor의 개수

- constructor는 클래스 내에 **최대 1개만** 존재할 수 있고, 2개 이상일 경우 `문법 에러(SyntaxError)`가 발생한다.
- constructor는 생략 가능하며, 생략시 **빈 constructor 가 암묵적으로 정의되어** 해당 클래스는 빈 객체를 생성한다.

#### 프로퍼티 초기화

- 생성자 함수 내부의 this는 생성한 인스턴스를 가리키며, 이를 통해 프로퍼티를 초기화 할 수 있다.
  ```js
  class Person {
    constructor(name, address) {
      this.name = name;
      this.address = address;
    }
  }
  ```

#### constructor return

- [생성자 함수의 인스턴스 생성 과정](https://github.com/likelion-ssu/JS-Deep-Dive/blob/main/JS%20Deep%20Dive%20cheat-sheet/17_생성자-함수에-의한-객체-생성.md#%EF%B8%8F-생성자-함수의-인스턴스-생성-과정) 처럼 클래스가 호출되면 **암묵적으로 this, 즉 인스턴스를 반환** 한다.
- 따라서 constructor 내에서 `return` 문을 사용해서는 안된다.
  - 다른 객체를 명시적으로 반환하면, this가 반환되지 않는다.
  - 다른 원시값을 명시적으로 반환하면 무시되고, 암묵적으로 this가 반환된다.

<br/>

### 프로토타입 메서드

- 클래스 몸체에서 정의한 메소드는 기본적으로 **프로토타입 메서드** 가 된다.
- 클래스가 생성한 인스턴스는 프로토타입 체인의 일원이 되며, 프로토타입 메서드를 상속받아 사용할 수 있다.
  ```js
  class Person {
    constructor(name) {
      this.name = name;
    }
    // 프로토타입 메서드
    sayHi() {
      console.log(`Hi! My name is ${this.name}`);
    }
  }
  ```

<br/>

### 정적 메서드

- **정적(static) 메서드** 는 인스턴스를 생성하지 않아도 호출할 수 있는 메서드를 말한다.
- 메서드에 `static` 키워드를 붙여 정적 메서드를 생성한다.
- 클래스 정의가 평가되는 시점에 클래스에 바인딩된다.
- 프로토타입 체인에 존재하지 않기 때문에 **인스턴스로 상속받을 수 없다.**
  ```js
  class Person {
    constructor(name) {
      this.name = name;
    }
    // 정적 메서드
    static sayHi() {
      console.log('Hi!');
    }
  }
  Person.sayHi(); // Hi!
  const me = new Person('Lee');
  me.sayHi(); // TypeError: me.sayHi is not a function
  ```

<br/>

### 정적 메서드와 프로토타입 메서드의 차이

1. 정적 메서드와 프로토타입 메서드는 속해있는 프로토타입 체인이 다르다.
2. 정적 메서드는 클래스로 호출하고 프로토타입 메서드는 인스턴스로 호출한다.
3. 정적 메서드는 인스턴스 프로퍼티를 참조할 수 없지만 프로토타입 메서드는 인스턴스 프로퍼티를 참조할 수 있다.

- 표준 빌트인 객체 `Math`, `Number`, `JSON`, `Object`, `Reflect` 등은 전역에서 사용하는 다양한 유틸리티 함수를 정적 메서드로 가지고 있다.
- 이러한 정적 메서드의 사용은 **이름 충돌 가능성** 을 줄여주고, 관련 함수들을 **구조화** 할 수 있다.
  ```js
  Math.max(1, 2, 3); // -> 3
  Number.isNaN(NaN); // -> true
  JSON.stringify({ a: 1 }); // -> "{"a":1}"
  Object.is({}, {}); // -> false
  Reflect.has({ a: 1 }, 'a'); // -> true
  ```

<br/>

### 클래스에서 정의한 메서드의 특징

1. `function` 키워드를 생략한 메서드 축약 표현을 사용한다.
2. 객체 리터럴과 다르게 정의할 때 콤마가 필요없다.
3. 암묵적으로 strict mode로 실행된다.
4. 프로퍼티 어트리뷰트 \[\[Enumerable]] 값이 `false`로 `for...in`, `Object.keys` 등으로 열거할 수 없다.
5. 내부 메서드 \[\[Construct]]를 갖지 않는 non-constructor이므로 `new` 연산자와 함께 호출할 수 없다.

<br/>

## 📌 25.6 클래스의 인스턴스 생성 과정

1. **인스턴스 생성과 `this` 바인딩**  
   `new` 연산자로 클래스를 호출하면 암묵적으로 빈 객체인 인스턴스가 생성된다.  
   인스턴스의 프로토타입으로 클래스의 prototype 프로퍼티의 객체가 설정된다.  
   인스턴스가 this에 바인딩된다.
2. **인스턴스 초기화**  
   constructor 내부 코드가 실행되어 `this`에 바인딩되어 있는 인스턴스를 초기화한다.
3. **인스턴스 반환**  
   완성된 인스턴스가 바인딩된 `this`가 암묵적으로 반환된다.

<br/>

## 📌 25.7 프로퍼티

### 인스턴스 프로퍼티

인스턴스 프로퍼티는 `constructor` 내부에서 정의해야한다.

- `constructor` 내부 코드 실행 이전 `this`에 이미 **인스턴스의 빈 객체** 가 바인딩되어있어, this에 인스턴스 프로퍼티를 추가하여 초기화 한다.
- 별도의 접근제한자는 제공되지 않으며, 인스턴스 프로퍼티는 `public` 하다.

### 접근자 프로퍼티

[접근자 프로퍼티](https://github.com/likelion-ssu/JS-Deep-Dive/blob/main/JS%20Deep%20Dive%20cheat-sheet/16_프로퍼티-어트리뷰트.md#-접근자-프로퍼티)는 \[\[value]] 내부 슬롯을 갖지 않고 다른 데이터 프로퍼티의 값을 읽거나 저장할 때 사용하는 `접근자 함수(accessor function)`로 구성된 프로퍼티 이다.

- `get` 키워드와 `set` 키워드를 사용하여 정의한다.
  ```js
  class Person {
    constructor(firstName, lastName) {
      this.firstName = firstName;
      this.lastName = lastName;
    }
    get fullName() {
      return `${this.firstName} ${this.lastName}`;
    }
    set fullName(name) {
      [this.firstName, this.lastName] = name.split(' ');
    }
  }
  const me = new Person('Ungmo', 'Lee');
  console.log(`${me.firstName} ${me.lastName}`); // Ungmo Lee
  me.fullName = 'Heegun Lee';
  console.log(me.fullName); // Heegun Lee
  ```

<br/>

### 클래스 필드 정의 제안

**클래스 필드(class field)** 는 클래스 기반 객체지향 언어에서 클래스가 생설할 **인스턴스의 프로퍼티** 를 말한다.

- 클래스 기반 객체지향 언어 자바의 클래스 필드는 클래스 내부에 변수처럼 `this` 없이 선언한다.
- 자바스크립트의 클래스 몸체(class body)에는 메서드만 선언할 수 있어 `문법 에러(SyntaxError)`가 발생한다.
  ```js
  class Person {
    name = 'name';
  }
  ```
- 하지만 자바스크립트도 클래스 기반 객체지향 언어의 클래스 필드처럼 정의할 수 있는 사양 `Class field declarations`가 \*TC39 프로세스 stage3(candidate)에 제안되어있다.(2021.01 기준)
- 표준 승급이 확실시되므로 최신 브라우저(Chrome 72 이상)와 최신 Node.js(12 이상)에서는 이미 구현되어있어, 위와 같이 선언할 수 있다.

_\* TC39는 ECMAScript의 관리를 담당하는 위원회이며, TC39 프로세스를 통해 새로운 사양 제안을 추가하고 승급시킨다._

클래스 필드는 다음과 같은 특징을 갖는다.

- `this`는 클래스의 constructor와 메서드 내에서만 유요하므로, 클래스 필드를 정의할 때 this를 바인딩해서는 안된다.
  ```js
  class Person {
    // this에 클래스 필드를 바인딩해서는 안된다.
    this.name = ''; // SyntaxError: Unexpected token '.'
  }
  ```
- 클래스 필드를 참조할 때에는 `this`를 반드시 사용해야한다.
  ```js
  class Person {
    name = 'Lee';
    constructor() {
      console.log(name); // ReferenceError: name is not defined
    }
  }
  ```
- 초기값을 할당하지 않으면 `undefined`를 갖는다.
- **함수** 는 일급 객체이므로 클래스 필드에 할당할 수 있다. 하지만 이는 클래스의 메서드가 아니라 인스턴스의 메서드가 되므로 권장하지 않는다.

결과적으로 인스턴스 프로퍼티를 생성할 수 있는 방식은 두 가지가 되었다. 다음과 같이 적절한 방식을 선택하여 사용하면 된다.

```js
// 클래스 필드 정의 제안
class Person {
  name = 'Lee';
  constructor() {}
}
// constructor에서 인스턴스 프로퍼티 정의
class Person {
  constructor(name) {
    this.name = name;
  }
}
```

- 인스턴스 생성시 외부 초기값으로 클래스 필드를 초기화할 필요가 있다면 **constructor에서 정의** 하는 방식을 사용한다.
  - 초기화하려면 constructor에서 this로 참조하여 다시 초기값을 할당해야하며, constructor 밖에서 클래스 필드를 정의하지 않아도 클래스 필드에 자동으로 프로퍼티가 추가되기 때문이다.
- 초기화할 필요가 없다면 **constructor에서의 정의** 방식과, **클래스 필드 정의 제안** 방식 모두 사용이 가능하다.

<br/>

### private 필드 정의 제안

자바스크립트는 `private`, `public`, `protected` 등의 접근제한자를 지원하지 않으며, 인스턴스의 프로퍼티는 `public`하다.

현재 TC39 프로세스의 stage3(candidate)에 `private` 필드를 정의할 수 있는 새로운 사양이 제안되어있으며, 클래스 필드 정의 제안과 동일하게 이미 최신 브라우저와 최신 Node.js 환경에서 구현되어있다.

```js
class Person {
  // private 필드 정의
  #name = '';
  constructor(name) {
    // private 필드 참조
    this.#name = name;
  }
}
const me = new Person('Lee');
console.log(me.#name);
// SyntaxError: Private field '#name' must be declared in an enclosing class
```

- private 필드는 오직 클래스내부에서만 직접 접근할 수 있다.
- 접근자 프로퍼티를 통해 간접적으로 접근할 수 있다.
  ```js
  class Person {
    #name = '';
    constructor(name) {
      this.#name = name;
    }
    get name() {
      return this.#name.trim();
    }
  }
  const me = new Person(' Lee ');
  console.log(me.name); // Lee
  ```
- private 필드는 반드시 클래스 몸체에 정의해야한다. constructor에서 정의하면 에러가 발생한다.
  ```js
  class Person {
    constructor(name) {
      this.#name = name;
      // SyntaxError: Private field '#name' must be declared in an enclosing class
    }
  }
  ```

<br/>

### static 필드 정의 제안

`static` 키워드를 사용하여 정적 메서드를 정의할 수 있었지만, 정적 필드를 정의할 수는 없었다.

현재 TC39 프로세스의 stage 3(candidate)에 `static public 필드`, `static private 필드`, `static private 메서드`를 정의할 수 있는 새로운 표준 사양 `Static class features`가 제안되어있으며 이미 최신 브라우저와 최신 Node.js 환경에서 구현되어있다.

```js
class MyMath {
  // static public 필드 정의
  static PI = 22 / 7;
  // static private 필드 정의
  static #num = 10;
  // static 메서드
  static increment() {
    return ++MyMath.#num;
  }
}
console.log(MyMath.PI); // 3.142857142857143
console.log(MyMath.increment()); // 11
```

<br/>

## 📌 25.8 프로퍼티

### 클래스 상속과 생성자 함수 상속

프로토타입 기반 상속은 프로토타입 체인을 통해 다른 객체의 자산을 상속받는 개념이지만, **상속에 의한 클래스 확장은 기존 클래스를 상속받아 새로운 클래스를 확장(extends)하여 정의** 하는 것이다.

- 클래스 상속을 통해 다른 클래스를 확장할 수 있는 문법인 `extends` 키워드가 기본적으로 제공된다.

[_image reference_](https://velog.io/@hang_kem_0531/TIL-모던-자바스크립트-Deep-Dive-클래스-2)

<br/>

### extends 키워드

### 동적 상속

### 서브클래스의 constructor

### super 키워드

### 상속 클래스의 인스턴스 생성 과정

### 표준 빌트인 생성자 함수 확장
